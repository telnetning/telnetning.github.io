<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>从C的do-while到Golang的defer、Python的with、CPP的RAII · ncg.moe</title><meta name="description" content="从C中的 do-while(1) 说起看到有推文讨论 do-while(0) 的用法，其实是一种为了流程控制的技巧，主要是用来替代 goto，对异常分支做处理。
123456789101112131415161718192021HRESULT CSampleQueue::Create(CSample"><meta name="og:description" content="从C中的 do-while(1) 说起看到有推文讨论 do-while(0) 的用法，其实是一种为了流程控制的技巧，主要是用来替代 goto，对异常分支做处理。
123456789101112131415161718192021HRESULT CSampleQueue::Create(CSample"><meta name="twitter:site" content="ncg.moe"><meta name="twitter:title" content="从C的do-while到Golang的defer、Python的with、CPP的RAII"><meta name="twitter:card" content="summary"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/js/prism/prism.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 7.1.1"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div class="container" id="stage"><div class="row"><div class="col-sm-3 col-xs-12 side-container invisible" id="side-bar"><div class="vertical-text site-title"><h3 class="site-title-small" tabindex="-1"><a class="a-title" href="/">如诗如歌</a></h3><h1 class="site-title-large" tabindex="-1"><a class="a-title" href="/">ncg.moe</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div class="site-title-links" id="site-nav"><ul><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li class="soc"><a href="http://ncg.moe/atom.xml" target="_blank" rel="noopener noreferrer" aria-label="RSS"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2024&nbsp;<a target="_blank" href="http://ncg.moe" rel="noopener noreferrer">ncg.moe</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div class="col-sm-9 col-xs-12 main-container invisible" id="main-container"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>从C的do-while到Golang的defer、Python的with、CPP的RAII</a></p><p class="post-meta"><span class="date meta-item">发布于&nbsp;2024-05-05</span></p><p class="post-abstract"><h3 id="从C中的-do-while-1-说起"><a href="#从C中的-do-while-1-说起" class="headerlink" title="从C中的 do-while(1) 说起"></a>从C中的 do-while(1) 说起</h3><p>看到有推文讨论 do-while(0) 的用法，其实是一种为了流程控制的技巧，主要是用来替代 goto，对异常分支做处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">HRESULT <span class="title function_">CSampleQueue::Create</span><span class="params">(CSampleQueue ** ppQueue)</span></span><br><span class="line">&#123;</span><br><span class="line">	HRESULT hr = S_OK;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">do</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (ppQueue == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			hr = E_POINTER;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		PNewQueue = new CSampleQueue();</span><br><span class="line">		<span class="keyword">if</span> (pNewQueue == <span class="literal">NULL</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			hr = E_OUTOFMEMORY;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 do-while(false) 相当于定义了一个 goto label，而在每次异常分支中，break 就相当于 goto 当了这个 lable。整体比起 goto，看起来优雅一些；另外可能就是，一个众所周知的原则就是项目中一般都不允许使用 goto（其实好像没有太多道理，尤其是在 C 语言中）。<br>整体的用法上有点像一个土法的 <code>try-catch</code>的简单炮制。</p>
<p>一个多层嵌套的场景：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition1) &#123;</span><br><span class="line">	<span class="keyword">if</span> (condition2) &#123;</span><br><span class="line">		<span class="keyword">if</span> (condition3)&#123;</span><br><span class="line">			<span class="comment">// if error</span></span><br><span class="line">			<span class="keyword">goto</span> ERROR_EXIT;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// if error</span></span><br><span class="line">		<span class="keyword">goto</span> ERROR_EXIT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// if error</span></span><br><span class="line">	<span class="keyword">goto</span> ERROR_EXIT</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">do_normal_work;</span><br><span class="line"></span><br><span class="line">ERROR_EXIT：</span><br><span class="line">clear_something;</span><br></pre></td></tr></table></figure>

<p>换成 do-while(0)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (condition1) &#123;</span><br><span class="line">		<span class="keyword">if</span> (condition2) &#123;</span><br><span class="line">			<span class="keyword">if</span> (condition3) &#123;</span><br><span class="line">				<span class="comment">// if error</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// if error</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// if error</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	do_normal_work;</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">clear_somethig;</span><br></pre></td></tr></table></figure>

<p>类似于 Python 中的 <code>try-except-finally</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	<span class="keyword">if</span> condition1:</span><br><span class="line">		<span class="comment"># if error</span></span><br><span class="line">		<span class="keyword">raise</span> some_exception1</span><br><span class="line">		<span class="keyword">if</span> condition2:</span><br><span class="line">			<span class="comment"># if error</span></span><br><span class="line">			<span class="keyword">raise</span> some_exception2</span><br><span class="line">			<span class="keyword">if</span> condition3:</span><br><span class="line">				<span class="comment"># if error</span></span><br><span class="line">				<span class="keyword">raise</span> some_exception3</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;some error happened.&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="comment"># 正常流程</span></span><br><span class="line">	do_normal_work</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">	<span class="comment"># 不管正常流程还是异常流程</span></span><br><span class="line">	clear_something</span><br></pre></td></tr></table></figure>

<p>为什么 C 中会有这种写法，主要的原因是，C 语言中，没有类似于 <code>try-catch</code>这种异常处理方式，对于一些稍微大型一点的工程，又有一些比较强的编码规范，导致代码实在臃肿和难以阅读。比如，编码规范可能要求了：<br>1）函数的返回值普遍都是错误码。<br>2）每个函数的调用的异常都要处理，不能忽略。<br>如果再加上一些更加苛刻的条件：<br>1）尽量不能使用 goto。<br>2）不能有超过X行代码的重复。<br>这对于写代码的人来讲，实在是一种摧残。</p>
<h4 id="一个普通的写法"><a href="#一个普通的写法" class="headerlink" title="一个普通的写法"></a>一个普通的写法</h4><p>可能会写出类似于下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">ErrCode <span class="title function_">LockAndLoadFileToStrPoint</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> **strResult)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(filename != <span class="literal">NULL</span>);</span><br><span class="line">    assert(strResult != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXBUFLEN 1000000</span></span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;g_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* malloc buffer to store content read */</span></span><br><span class="line">    <span class="type">char</span> *buffer = (<span class="type">char</span> *) <span class="built_in">malloc</span>(MAXBUFLEN);</span><br><span class="line">    <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;g_mutex);</span><br><span class="line">        <span class="keyword">return</span> E_NOMEMORY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* open */</span></span><br><span class="line">    FILE *fp = fopen(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">free</span>(buffer);</span><br><span class="line">        pthread_mutex_unlock(&amp;g_mutex);</span><br><span class="line">        <span class="keyword">return</span> E_OPEN_FILE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* read */</span></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> symbol = EOF;</span><br><span class="line">    <span class="keyword">while</span>((symbol = getc(fp)) != EOF) &#123;</span><br><span class="line">        buffer[index++] = symbol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* some other operation to call some funcs */</span></span><br><span class="line">    ErrCode e_code = DoSomeOtherOperation(buffer);</span><br><span class="line">    <span class="keyword">if</span> (e_code != E_OK) &#123;</span><br><span class="line">        fclose(fp);</span><br><span class="line">        pthread_mutex_unlock(&amp;g_mutex);</span><br><span class="line">        <span class="keyword">return</span> e_code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* clean */</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">    pthread_mutex_unlock(&amp;g_mutex);</span><br><span class="line"></span><br><span class="line">    *strResult = buffer;</span><br><span class="line">    <span class="keyword">return</span> E_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码比较臃肿，并且在不断地异常判定中，需要不断地析构清理资源。</p>
<h4 id="goto-写法"><a href="#goto-写法" class="headerlink" title="goto 写法"></a>goto 写法</h4><p>所以一般不得不引入 goto 语句，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">ErrCode <span class="title function_">LockAndLoadFileToStrPoint</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> **strResult)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(filename != <span class="literal">NULL</span>);</span><br><span class="line">    assert(strResult != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXBUFLEN 1000000</span></span><br><span class="line"></span><br><span class="line">    ErrCode errCode = E_OK;</span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> *buffer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;g_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* malloc buffer to store content read */</span></span><br><span class="line">    buffer = (<span class="type">char</span> *) <span class="built_in">malloc</span>(MAXBUFLEN);</span><br><span class="line">    <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        errCode = E_NOMEMORY;</span><br><span class="line">        <span class="keyword">goto</span> ERR_EXIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* open */</span></span><br><span class="line">    fp = fopen(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        errCode = E_OPEN_FILE;</span><br><span class="line">        <span class="keyword">goto</span> ERR_EXIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* read */</span></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> symbol = EOF;</span><br><span class="line">    <span class="keyword">while</span>((symbol = getc(fp)) != EOF) &#123;</span><br><span class="line">        buffer[index++] = symbol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* some other operation to call some funcs */</span></span><br><span class="line">    ErrCode e_code = DoSomeOtherOperation(buffer);</span><br><span class="line">    <span class="keyword">if</span> (e_code != E_OK) &#123;</span><br><span class="line">        <span class="keyword">goto</span> ERR_EXIT;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    *strResult = buffer;</span><br><span class="line"></span><br><span class="line">ERR_EXIT:</span><br><span class="line">    <span class="comment">/* clean */</span></span><br><span class="line">    <span class="keyword">if</span> (fp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fclose(fp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (buffer != <span class="literal">NULL</span> &amp;&amp; errCode != E_OK) &#123;</span><br><span class="line">        <span class="built_in">free</span>(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;g_mutex);</span><br><span class="line">    <span class="keyword">return</span> errCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引入 goto 使得流程控制变得简单，所以我们可以统一在 goto 的 label 处设置一个出口，在出口处判定我们使用过的资源是否需要释放，以及进行清理释放操作。</p>
<h4 id="do-while-0-写法"><a href="#do-while-0-写法" class="headerlink" title="do-while(0) 写法"></a>do-while(0) 写法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">ErrCode <span class="title function_">LockAndLoadFileToStrPoint</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> **strResult)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(filename != <span class="literal">NULL</span>);</span><br><span class="line">    assert(strResult != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXBUFLEN 1000000</span></span><br><span class="line"></span><br><span class="line">    ErrCode errCode = E_OK;</span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> *buffer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;g_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">/* malloc buffer to store content read */</span></span><br><span class="line">      buffer = (<span class="type">char</span> *) <span class="built_in">malloc</span>(MAXBUFLEN);</span><br><span class="line">      <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        errCode = E_NOMEMORY;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* open */</span></span><br><span class="line">      fp = fopen(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">          errCode = E_OPEN_FILE;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="comment">/* read */</span></span><br><span class="line">      <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="type">char</span> symbol = EOF;</span><br><span class="line">      <span class="keyword">while</span>((symbol = getc(fp)) != EOF) &#123;</span><br><span class="line">          buffer[index++] = symbol;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* some other operation to call some funcs */</span></span><br><span class="line">       ErrCode e_code = DoSomeOtherOperation(buffer);</span><br><span class="line">       <span class="keyword">if</span> (e_code != E_OK) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       *strResult = buffer;</span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* clean */</span></span><br><span class="line">    <span class="keyword">if</span> (fp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fclose(fp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (buffer != <span class="literal">NULL</span> &amp;&amp; errCode != E_OK) &#123;</span><br><span class="line">        <span class="built_in">free</span>(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;g_mutex);</span><br><span class="line">    <span class="keyword">return</span> errCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体写法基本就是把 goto 的地方换成了 break，流程控制和 goto 完全一致，只是看起来更优雅一点。</p>
<h3 id="GoLang-中的-defer"><a href="#GoLang-中的-defer" class="headerlink" title="GoLang 中的 defer"></a>GoLang 中的 defer</h3><h4 id="为什么设计了-defer-关键字"><a href="#为什么设计了-defer-关键字" class="headerlink" title="为什么设计了 defer 关键字"></a>为什么设计了 defer 关键字</h4><p>Go语言的整体设计是比较克制的，总共的关键字也一共只有 25 个，但是其中就包含了 defer。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">break     default      func    interface  select</span><br><span class="line">case      defer        go      map        struct</span><br><span class="line">chan      else         goto    package    switch</span><br><span class="line">const     fallthrough  if      range      type</span><br><span class="line">continue  for          import  return     var</span><br></pre></td></tr></table></figure>
<p>go 语言设计 defer 主要是为了更加方便地清理资源——在思维和写法上，都能够在开启资源的时候，就同时处理好了资源的关闭清除操作。</p>
<p>官方 blog 中的样例<a target="_blank" rel="noopener" href="https://go.dev/blog/defer-panic-and-recover">Defer, Panic, and Recover</a><br>不用 defer 的写法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyFile</span><span class="params">(dstName, srcName <span class="type">string</span>)</span></span> (written <span class="type">int64</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    src, err := os.Open(srcName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dst, err := os.Create(dstName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    written, err = io.Copy(dst, src)</span><br><span class="line">    <span class="comment">/* 这里距离我们打开 dst、src 已经很远了 */</span></span><br><span class="line">    dst.Close() </span><br><span class="line">    src.Close()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 defer 重写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyFile</span><span class="params">(dstName, srcName <span class="type">string</span>)</span></span> (written <span class="type">int64</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    src, err := os.Open(srcName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* src 打开成功，defer close */</span></span><br><span class="line">    <span class="keyword">defer</span> src.Close()</span><br><span class="line"></span><br><span class="line">    dst, err := os.Create(dstName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* dst 打开成功，defer close */</span></span><br><span class="line">    <span class="keyword">defer</span> src.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> io.Copy(dst, src)</span><br><span class="line">    <span class="comment">/* 这里不再需要了 */</span></span><br><span class="line">    <span class="comment">// dst.Close() </span></span><br><span class="line">    <span class="comment">// src.Close()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>个人的想法是，Go 是一门偏向工程化设计的语言，defer 关键字的设计是这种思想的一个具象化体现。Python 或者 Java 等中的 try-catch(except)-finally 语法相比 defer 有更明确的 scope，而 defer 像是一个语法糖，则是有一种暴力直接的美。</p>
<h4 id="defer-的实现原理"><a href="#defer-的实现原理" class="headerlink" title="defer 的实现原理"></a>defer 的实现原理</h4><p>defer 的直接意思是<code>延迟执行</code>，defer 将其声明的方法调用推迟到函数 return 之前调用。<br>defer 的实现上是借助了自己对函数调用栈的管理。<br>defer 声明的方法，在编译时被实现为对回调函数 deferproc 或者 deferprocStack 的调用。deferproc 和 deferprocStack 的区别在于  defer 对应的结构体 <code>_defer</code> 的空间是在堆上还是在栈上以及带来的性能差异，其他的无区别，以下统一称作 deferproc。<br>deferproc 会将 defer 生成的 <code>_defer</code> 对象，<strong>以链表的形式，挂在 Goroutine 的 <code>_defer</code> 表头上</strong>。从而在 defer 所在的函数返回时，依次对注册的 defer 方法进行调用。</p>
<p>另外，含有 defer 的函数，在编译中，也被添加了对函数 deferreturn 的调用。<br>deferreturn 方法中，会依次遍历该函数注册过的 defer，依次调用后从链表中删除。<br>按照一般的函数栈的实现，调用顺序或者栈如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">caller -&gt; deferreturn -&gt; defer func -&gt; deferreturn -&gt; defer func ... -&gt; return to deferreturn -&gt; return to caller </span><br></pre></td></tr></table></figure>

<p>Go在实际的实现中，通过一小段汇编<code>jmpdefer</code>将调用顺序改成如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">caller -&gt; deferreturn -&gt; defer func -&gt; return to caller(这里直接返回到了 caller)-&gt; deferreturn -&gt; ...</span><br></pre></td></tr></table></figure>

<p>实现的原理是：<br>caller 虽然调用了 deferreturn 形成了 deferreturn 的栈帧，但是并不使用它，在获取了 defer func 的信息之后，调用 defer func 之前，改写了 函数栈帧的返回地址，并且重置了 rbp。<br>能够改写函数栈帧的返回地址的原因是，<code>_defer</code>结构体中记录了 defer 注册时的 rsp 的值，实际上就是 caller 的 rsp 的值，从而拿到调用 deferreturn 时的返回地址的栈空间地址，并且该地址指向 deferreturn 的下一个指令，将该值倒退5，就拿到了 deferreturn 本身的指令地址，并设置到了返回地址——从而实现了 deferreturn 的循环调用，知道 Goroutine 的 <code>_defer</code>中没有了该函数注册的 defer 调用。</p>
<p>其中关键的 jmpdefer 解释如下（来自参考1）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·jmpdefer(SB), NOSPLIT, $0-16</span><br><span class="line">    MOVQ    fv+0(FP), DX    // 取出延迟回调函数 fn 地址 </span><br><span class="line">    MOVQ    argp+8(FP), BX  // 取出 caller  函数的 rsp 值</span><br><span class="line">    LEAQ    -8(BX), SP      // rsp 向下扩展8，此时已经覆盖了 deferreturn 的栈帧，变成了构造 defer func 的栈帧</span><br><span class="line">    MOVQ    -8(SP), BP      // 还原 caller 栈帧寄存器</span><br><span class="line">    SUBQ    $5, (SP)        // 重要操作，这个把压栈在栈顶的值修改了。之前压的是 caller 函数内，调用 deferreturn 之后下一行指令，现在压的是 call runtime.deferreturn 这行值。</span><br><span class="line">    MOVQ    0(DX), BX       // 取出 fn 函数指令地址，存到 rbx 寄存器</span><br><span class="line">    JMP     BX              // 跳到延迟回调函数执行</span><br></pre></td></tr></table></figure>

<p>整体的思想就是，调用 deferreturn 只是为了调用 defer func，deferreturn 的栈帧是没有意义的，直接在 deferreturn 的栈帧上覆盖构造了 defer func 的栈帧，手动设置了栈帧的  <code>|返回地址|rbp|defer 处理的栈帧|</code>，保证返回到 caller 循环调用 deferreturn 这条指令。</p>
<h4 id="defer-的使用、注意事项"><a href="#defer-的使用、注意事项" class="headerlink" title="defer 的使用、注意事项"></a>defer 的使用、注意事项</h4><p>结合 defer 的实现，可以更容易理解 defer 的一些特点和使用过程中需要注意的地方。</p>
<p>1）多个 defer 的 FILO 特性<br>因为一个函数中的所有 defer 是用链表串起来的，因此实现上就需要取舍是 FIFO 还是 FILO。从 defer 的设计场景来看，FILO 是更合适的——比如申请使用的资源之间可能是有一定的逻辑关系的，先申请的资源，一般最后释放比较好。</p>
<p>2）defer 调用的参数是预计算的。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(i) <span class="comment">// 这里打印的结果是 0</span></span><br><span class="line">    i++</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然 caller 对 defer func 的调用是标准的函数调用，但是出于将 defer 的参数设计成预计算的，对编译器是更加友好的，同时也简化了实现，使得 defer 的调用的结果更加具有明确性。<br>从实现上看，<code>_defer</code>结构体是一个类似于 header 的定义，所以其第一个字段就是 siz，记录了自己占用的内存的大小，在结构体本身确定内存长度的字段后，有一块内存区域用来放置参数，紧挨着 <code>_defer</code> 放置。<br>在 deferreturn 构造 caller 调用 defer func 的代码中，同时也构造了 caller 调用 defer func 所需要的参数，即从 <code>_defer</code>结构体内存中拷贝到 caller 的栈帧中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> siz &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="comment">// Do nothing.</span></span><br><span class="line">	<span class="keyword">case</span> sys.PtrSize:</span><br><span class="line">		*(*<span class="type">uintptr</span>)(deferArgs(d)) = *(*<span class="type">uintptr</span>)(unsafe.Pointer(argp))</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		memmove(deferArgs(d), unsafe.Pointer(argp), <span class="type">uintptr</span>(siz))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想要不使用预计算的特性，也可以使用 golang 中的闭包的特性，定义 defer 函数。</p>
<p>3）defer 可以修改 caller 的有名返回值<br>这个特性应该是故意设计出来的，可以方便在 caller 函数返回之前，对函数的返回值做一些修改，比如修改 caller 的返回错误码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return 2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">c</span><span class="params">()</span></span> (i <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; i++ &#125;()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）defer 执行的时机<br>都知道 defer 是在函数返回之前执行，但是实际上，return 本身并不是一个原子指令。<br>callee 返回时，需要设置 caller 的返回值，需要恢复 rbp，缩减 rsp。<br>根据官方说法，defer 是在设置完返回值后，返回前执行的，即：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设置返回值 -&gt; 调用 defer 链 -&gt; 函数返回</span><br></pre></td></tr></table></figure>

<h3 id="Python-中的上下文管理"><a href="#Python-中的上下文管理" class="headerlink" title="Python 中的上下文管理"></a>Python 中的上下文管理</h3><p>go 语言中的 defer 实现，很容易让人联想到 Python 中的 with 实现。<br>使用 with，资源可以做到自动的释放管理，在离开 with 的 scope 时，with 打开的资源，会被自动释放：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def fun():</span><br><span class="line">    with open(file, &quot;w&quot;) as f:</span><br><span class="line">        f.write(&quot;hello world&quot;)</span><br></pre></td></tr></table></figure>

<p>这里并不再需要手动调用 f.close()，看起来更优雅一点，思想有点像析构函数。</p>
<p>with 的实现是基于 Python 中的上下文管理的。一个类，给其定义 <code>__enter__</code> 方法和 <code>__exit__</code>方法，那么上下文管理器，就可以在使用该类时，在对应时机调用 <code>__enter__</code> 方法和 <code>__exit__</code>方法。</p>
<p>with 是可以用来替代 try-finally 的，<code>__exit__</code>的参数包含了异常的类型、对象以及堆栈信息。</p>
<h3 id="CPP-中的-RAII-和-scope-exit"><a href="#CPP-中的-RAII-和-scope-exit" class="headerlink" title="CPP 中的 RAII 和 scope_exit"></a>CPP 中的 RAII 和 scope_exit</h3><p>cpp 中有类似的思想实践，叫做 RAII。RAII 的想法是，将资源的生命周期绑定到一个对象上，利用对象的析构的特性在 scope 结束的时候，自动调用资源的释放方法。<br>因此，RAII 的另外一个名字叫做，SBRM(Scope Bound Resource Manger)，资源作用域绑定管理——在使用完对象之后，scope exit 的时候 RAII 的生命周期也结束。</p>
<p>RAII 总结如下：<br>1）将对象封装到 class 中，在 class 的构造方法中，获取资源；在 class 的析构方法中，释放资源。<br>2）始终使用 class 封装的 RAII 对象。</p>
<p>另外，CPP 中有叫做 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/experimental/scope_exit">scope_exit</a> 的 experimental 特性，也是为了相同的目的。</p>
<h3 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h3><ul>
<li><a target="_blank" rel="noopener" href="https://twitter.com/Ari76184709/status/1779852870701191492">一个关于do-while-false的推文讨论</a></li>
<li><a target="_blank" rel="noopener" href="https://www.qiyacloud.cn/2021/02/2021-02-08/">Golang 最细节篇 — 解密 defer 原理</a></li>
<li><a target="_blank" rel="noopener" href="https://www.luozhiyun.com/archives/523">深入 Go 语言 defer 实现原理</a></li>
<li><a target="_blank" rel="noopener" href="https://go.dev/blog/defer-panic-and-recover">Defer, Panic, and Recover</a></li>
<li><a target="_blank" rel="noopener" href="https://www.v2ex.com/t/1036972">golang 的 defer 真是个好设计</a></li>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-defer/#53-defer">Go 语言设计与实现 – defer</a></li>
<li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/raii">cpp reference – RAII</a></li>
</ul>
</p></div><div class="share"><span>分享到</span>&nbsp;<span class="soc"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></span><span class="soc"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></span><span class="soc"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=http://ncg.moe/2024/05/05/do_while_zero_and_defer_and_with_and_raii/%20ncg.moe%20从C的do-while到Golang的defer、Python的with、CPP的RAII"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/2024/07/13/read_the_native_posix_thread_library_for_linux/" title="论文阅读笔记：The Native POSIX Thread Library for Linux"><i class="fa fa-angle-double-left"></i>&nbsp;上一篇: 论文阅读笔记：The Native POSIX Thread Library for Linux</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/2024/04/05/just_for_fun/" title="一边好玩，一遍改变世界">下一篇: 一边好玩，一遍改变世界&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2024&nbsp;<a target="_blank" href="http://ncg.moe" rel="noopener noreferrer">ncg.moe</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script><script src="/js/prism/prism.js"></script></body></html>